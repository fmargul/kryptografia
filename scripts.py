# -*- coding: utf-8 -*-
"""ECC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XJWVUO8qAVrD408zUbn-U8C6gAF7ncaj
"""

import numpy as np
import math
import random

def is_prime(n):
  if (n <= 1): return False
  for i in range(2, int(math.sqrt(n)) + 1):
    if(n % i == 0):
      #print(i)
      return False
  return True

def find_next_prime_if_not_prime(n): #fajnie jakby wpisywane liczby były większe od 2 lub nawet wyżej
  if (is_prime(n)): return int(n)
  else:
    next_number = n + 1
    while not is_prime(next_number):
      next_number += 1
    return int(next_number)

def is_prime_by_probability(n, accuracy):
  if (n <= 1): return False
  if n == 2 or n == 3: return True
  if (n % 2 == 0): return False

  s = 0
  d = n - 1
  while d % 2 == 0:
    d //= 2
    s += 1

  for _ in range(accuracy):
    a = random.randint(2, n - 2)
    x = pow(a, d, n)

    if x == 1 or x == n - 1:
      continue

    for _ in range(s - 1):
      x = pow(a, 2, n)
      if x == n - 1:
        break
      else:
        return False
  return True

# krzywa eliptyczna ma postac y^2 = x^3 + ax + b
# Funckja sprawdza, czy argument X należy do krzywej eliptycznej nad ciałem o wielkości p
# Jeśli nie to bierzę następną liczbę całkowitą, która należy do krzywej eliptycznej
def ECDH_check_X(a, b, p, X, positive):
  X = int(X) % p
  Y2 = (X**3 + a*X + b) % p
  Y = math.sqrt(Y2)
  if Y % 1 == 0:
    if (positive): return X, int(Y)
    else:
      Y = -Y
      Y = Y % p
      return X, int(Y)
  else:
    if pow(Y2, int((p-1)/2), p) == 1:
      if p % 4 == 3:
        Y = pow(Y2, int((p+1)/4), p)
        if (positive): return X, int(Y)
        else:
          Y = -Y
          Y = Y % p
          return X, int(Y)
      else: return ECDH_check_X(a, b, p, X+1, positive)
    else: return ECDH_check_X(a, b, p, X+1, positive)

def ECC_point_to_point(P, Q, k, p, a):
  R = Q
  xp, yp = P
  for _ in range(k-1):
    Q = R
    if (Q != P):
      xq, yq = Q
      s = (yq - yp) * pow(xq - xp, -1, p) % p
      xr = (s**2-xq-xp) % p
      yr = (s*(xq-xr)-yq) % p
      R = xr, yr
    else:
      s = (3 * xp ** 2 + a) * pow(2 * yp, -1, p) % p
      xr = (s**2-2*xp) % p
      yr = (s*(xp - xr) - yp) % p
      R = xr, yr
  return R

def generate_public_key_ECDH(a, b, c, p, X, positive):
  p = find_next_prime_if_not_prime(p)
  G = ECDH_check_X(a, b, p, X, positive)
  C = ECC_point_to_point(G, G, c, p, a)
  return C

a = 322
b = 964
p = 112300000
X = 22
c = 60
d = 40
cd = c*d
positive = True

def generate_private_key_ECDH(a, b, d, p, C):
  p = find_next_prime_if_not_prime(p)
  cdG = ECC_point_to_point(C, C, d, p, a)
  return cdG

def generate_private_key_rightaway_ECDH(a, b, c, d, p, X, positive):
  C = generate_public_key_ECDH(a, b, c, p, X, positive)
  cdG = generate_private_key_ECDH(a, b, d, p, C)
  return cdG

C = generate_public_key_ECDH(a, b, c, p, X, positive)
print(C)
cdG = generate_private_key_ECDH(a, b, d, p, C)
print(cdG)

generate_private_key_rightaway_ECDH(a, b, c, d, p, X, positive)